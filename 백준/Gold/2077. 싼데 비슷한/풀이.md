## 풀이
* 비둘기집 원리를 이용해 구역을 4등분으로 나눔
* 그 중 1/4 최소 구역을 버림
* 그러므로 문제는 항상 75%이상을 광석을 캘 수 있음(기계특성상)
* 출력이 까다로운데 가장 n을 적게 감소시키는 것부터 출력 후 0333 이어서 출력
* 중요한 건 이 문제는 최소 광석 손해를 구하는 것이 아니라 75%이상의 광성을 구하는데 목적이 있음
* 참고로 이 문제는 파이썬 언어로는 해결 할 수 없음(입력데이터를 무조건 리스트로 받는 언어 특성상)
## 자료구조 및 알고리즘
* 비둘기집 원리
## 문제 유형
* 수학
* 역추적
* 비둘기집 원리
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n)$
* 공간복잡도: $\mathcal{O}(1)$
## 코드
### C++
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

ll S[4];

int main(){
	cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
	int T; cin >> T; while(T--){
		cout << "YES\n";
		int n; cin >> n; S[0] = S[1] = S[2] = S[3] = 0;
		for(int i = 1; i <= n; i++){
			int t; cin >> t; S[i%4] += t;
		}
		ll m = min({S[0], S[1], S[2], S[3]});
		if(S[2] == m){
			cout << "0"; n--;
		}
		else if(S[3] == m){
			cout << "01"; n -= 2;
		}
		else if(S[0] == m){
			cout << "022"; n -= 3;
		}
		while(n >= 4){
			n -= 4; cout << "0333";
		}
		if(n) cout << 0;
		if(n == 2) cout << 1;
		if(n == 3) cout << 22;
		cout << '\n';
	}
}
```
