## 풀이
1. 시간 제한이 정말 짧기 때문에 문제 그대로 코드를 작성했다간 문제를 성공하지 못합니다.
2. 연산의 최적화도 중요하지만 수학적 최적화가 무엇보다 중요합니다.
3. 핵심은 &, | 비트연산이 255 배수마다 이뤄지며 | 비트연산으로 X=i가 된다는 점입니다. 이를 통해서 계산 횟수를 줄일 수 있습니다.
## 자료구조 및 알고리즘
* 없음
## 문제 유형
* 수학
* 애드 혹
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(1)$
* 공간복잡도: $\mathcal{O}(1)$
## 코드
```python
import sys

input=sys.stdin.readline

def main():
    p = 1000000007
    n = int(input())
    l = n - n % 255
    x = 0
    
    for i in range(l, n+1):
        x -= i
        x = abs(x)
        if i % 3 == 0: 
            x = (x * i) % p
        if i % 15 == 0:
            x &= i
        if i % 63 == 0:
            x ^= i
        if i % 255 == 0:
            x |= i
        if i % 1023 == 0:
            x = (x * pow(2, i, p)) % p
    
    sys.stdout.write(str(x))

if __name__ == '__main__':
    main()
```
