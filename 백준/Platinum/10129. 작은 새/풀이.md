## 풀이
### 관점 전환
* **dp[i] = i번째 나무에 도착했을 때의 최소 피로도**라는 기준을 먼저 잡습니다.
* 모든 나무에 대해서 dp를 하나씩 검사하며 최소 피로도를 구할 수도 있지만 비효율적입니다.
* 일단 주목해야 할 점은 피로도입니다. 피로도가 낮은 것을 최우선이 되는 나무를 먼저 정합니다.
* 만약 피로도가 같은 나무라면 높이가 가장 높은 나무를 정합니다. 어차피 아무리 나무가 높아도 피로도는 1만 쌓이기 때문입니다.
### 단조성 유지(Monotonic Queue)
* **어떤 기준에 대해 단조 증가 또는 단조 감소를 유지하도록 관리되는 자료구조**를 단조큐라고 부릅니다.
* 여기서는 나무를 지나갈 때마다 피로도 쌓일 수 있는 구조입니다.
* dp 덱에서 k범위를 벗어나는 덱은 앞에서 제거를 해줍니다.
* 다음은 현재의 피로도보다 뒤에 나무의 피로도가 더 높다면 덱의 뒤를 제거해 줍니다.
* 그런 식으로 단조성을 유지하면서 나무를 하나하나 검사하면 마지막 덱이 정답입니다.
## 문제 유형
* 다이나믹 프로그래밍, 자료 구조, 덱, 덱을 이용한 구간 최댓값 트릭, 덱을 이용한 다이나믹 프로그래밍
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(q × n)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
* CPython에선 시간초과로 제출이 불가능합니다. 반복문마다 덱, 객체를 여러 번 접근하기에 시간초과가 날 수 밖에 없다고 합니다.
### C++
```c++
#include<bits/stdc++.h>
using namespace std;

struct st{
    int idx, val, h;
};

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    int n; cin >> n;
    vector<int> h(n);
    for (int i = 0; i < n; i++) cin >> h[i];
    int q; cin >> q;

    while (q--){
        deque<st> dp;
        int k; cin >> k;

        dp.push_back({0,0,h[0]});

        for (int i = 1; i < n; i++){
            while (dp.size() && dp.front().idx + k < i) dp.pop_front();
            int now = dp.front().val + (bool)(dp.front().h <= h[i]);
            while (dp.size() && (dp.back().val > now || dp.back().val == now && dp.back().h <= h[i])) dp.pop_back();
            dp.push_back({i, now, h[i]});
        }
        cout << dp.back().val << endl;
    }
}
```
