## 풀이
* dp[x] = x원을 만드는 방법의 수라고 정합니다.
* 그러면 금액만큼의 dp 리스트가 필요합니다.
* 시작은 dp[0] = 1으로 기준을 잡습니다.
* 특정 금액에 추가로 코인을 하나씩 추가하면 생기는 경우의 수를 dp에 저장합니다.
* 최종 마지막 dp가 정답이 됩니다.
## 자료구조 및 알고리즘
* DP
## 문제 유형
* DP
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
### Python
```python
def solution(n, money):
    MOD = 1000000007
    dp = [0] * (n + 1)
    dp[0] = 1

    for coin in money:
        for x in range(coin, n+1):
            dp[x] += dp[x-coin]
    
    return dp[n] % MOD
```
### C++
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int solution(int n, vector<int> money) {
    const ll MOD = 1'000'000'007;

    vector<ll> dp(n + 1, 0);
    dp[0] = 1;

    for (int coin : money){
        for (int x = coin; x <= n; x++){
            dp[x] = (dp[x] + dp[x-coin]) % MOD;
        }
    }
    return dp[n];
}
```
