## 풀이
* 일일이 비교를 통해서도 문제를 해결할 수 있지만, 그럼 $\mathcal{O}(n^2)$ 비교를 해야 합니다.
* 정렬을 한다면 우리는 좀 더 수월하게 문제를 해결 할 수 있습니다.
* 첫번째 점수는 내림차순, 두번째 점수는 오름차순 정렬을 합니다. 그러면 첫번째 점수는 제외하고 두번째 점수의 비교만으로 원하는 결과를 얻을 수 있습니다.
* 두번째 점수의 비교만을 이용해서 완호가 통과하지 못할 경우 바로 return -1을 하고 아니라면 완호보다 점수가 높은 사람의 수 + 1이 완호의 등수입니다.
## 문제 유형
* 정렬 + 지배 관계(dominance) 기반 그리디
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n log n)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
### Python
```python
import sys
def print(*args, sep=" ", end="\n"):
    sys.stdout.write(sep.join(map(str, args)) + end)
def input():
    return sys.stdin.readline().rstrip()

def solution(scores):
    sorted_scores = sorted(scores, key = lambda x: (-x[0], x[1]))
    wanho = tuple(scores[0])
    wanho_sum = sum(wanho)
    maxs = -1
    rank = 1
    for f, s in sorted_scores:
        if s < maxs:
            if (f, s) == wanho:
                return -1
            continue

        maxs = s
        
        if f + s > wanho_sum:
            rank += 1

    return rank

def main():
    print(solution([[2,2],[1,4],[3,2],[3,2],[2,1]]))
if __name__ == '__main__':
    main()


```
### C++
```c++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;

int solution(vector<vector<int>> scores) {
    vector<int> wanho = scores[0];
    int wanho_sum = wanho[0] + wanho[1];
    sort(scores.begin(), scores.end(), [](const vector<int> &a, const vector<int> &b){
        if(a[0] != b[0]) return a[0] > b[0];
        return a[1] < b[1];
    });
    int maxs = -1; 
    int rank = 1;
    for(auto s : scores){
        if(s[1] < maxs){
            if(s[0] == wanho[0] && s[1] == wanho[1]) return -1;
            continue;
        }
        maxs = s[1];
        if(s[0] + s[1] > wanho_sum) rank++;
    }
    return rank;
}

int main(){
    cin.tie(0); cout.tie(0); ios::sync_with_stdio(false);
    cout << solution({{2,2}, {1,4}, {3,2}, {3,2}, {2,1}});
}
```
