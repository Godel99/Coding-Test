## 풀이
* 타임테이블을 정수 값으로 변환해 리스트로 저장합니다.
* 리스트를 정렬합니다.
* 버스 시간 기준으로 정렬된 리스트를 가지고 마지막 버스와 그 버스의 마지막 크루 시간을 기록합니다.
* 마지막 버스가 가득 찼다면 마지막 크루의 시간 - 1, 가득 차지 않았다면 마지막 버스 시간이 정답입니다.
## 자료구조 및 알고리즘
* 없음
## 문제 유형
* 시뮬레이션
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(K log K)$
* 공간복잡도: $\mathcal{O}(n)$
## 코드
### Python
```python
def solution(n, t, m, timetable):
    crew = []
    for time in timetable:
        hour, min = map(int, time.split(':'))
        crew.append(hour*60+min)
    crew.sort()
    crew_idx = 0
    last_time = 0
    
    for i in range(n):
        last_bus_time= 9 * 60 + t * i
        ridden = 0

        while crew_idx < len(crew) and crew[crew_idx] <= last_bus_time and ridden < m:
            last_time = crew[crew_idx]
            crew_idx += 1
            ridden += 1
        
    if ridden < m:
        result_time = last_bus_time 
    else:
        result_time = max(0, last_time - 1)

    H, M = divmod(result_time, 60)
    return f'{H:02d}:{M:02d}'
```
### C++
```cpp
#include<bits/stdc++.h>
#include <vector>
#include <string>
using namespace std;

string solution(int n, int t, int m, vector<string> timetable) {
    vector<int> crew;
    for (const string& time : timetable){
        int hour = stoi(time.substr(0, 2));
        int min = stoi(time.substr(3, 2));
        crew.push_back(hour * 60 + min);
    }

    sort(crew.begin(),crew.end());
    int crew_idx = 0;
    int last_crew_time = 0;
    int ridden;
    int last_bus_time;

    for (int i = 0; i < n; i++){
        last_bus_time = 9 * 60 + t * i;
        ridden = 0;

        while (crew_idx < crew.size() && crew[crew_idx] <= last_bus_time && ridden < m){
            last_crew_time = crew[crew_idx];
            crew_idx++;
            ridden++;
        }
    }

    int answer = 0;
    if (ridden < m) answer = last_bus_time;
    else answer = last_crew_time - 1;
    
    int H = answer / 60;
    int M = answer % 60;

    ostringstream oss;
    oss << setw(2) << setfill('0') << H
        << ":" 
        << setw(2) << setfill('0') << M;

    return oss.str(); 
}
```
