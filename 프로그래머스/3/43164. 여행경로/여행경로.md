# 문제 풀이
## 해결 과정
1. 항공권 입력을 그래프로 변환
2. 도착순으로 정렬
3. 여기서 두 가지 방법으로 해결 가능
4. DFS+BackTracking 방식: 항공권을 쓰면서 끝까지 가보다가 실패하면 백트래킹으로 복원
5. Hierholzer: 갈 수 있는 경로까지 끝까지 가보고 막히면 그 지점을 반환
6. 힉습 관점에서는 DFS+BackTracking으로 푸는 게 맞으나 최적화에서는 Hierholzer 접근이 좋음
## 사용된 자료구조 및 알고리즘
* DFS+BackTracking
* Hierholzer(오일러 경로(Eulerian Path))
## 문제 유형
* 그래프
* 깊이/너비 우선 탐색(DFS/BFS)
## 배운점
1. 슬라이싱의 기본 구조  
파이썬 리스트 슬라이싱은 기본적으로 3가지 인자를 가집니다.  
```list[start : stop : step]```
* start: 시작 인덱스 (포함)
* stop: 끝 인덱스 (포함되지 않음)
* step: 증감 폭 (보폭)
2. [::-1]의 동작 원리  
* start와 stop을 비워두고 step에 -1을 넣으면 파이썬은 다음과 같이 해석합니다.
* start 비어있음: step이 음수이므로, 리스트의 맨 끝을 시작점으로 잡습니다.
* stop 비어있음: 리스트의 맨 앞까지 가겠다는 의미입니다.
* step = -1: 뒤에서부터 한 칸씩 거꾸로 이동하며 요소를 추출합니다.
***
* DFS+BackTracking 코드
```python
from collections import defaultdict

def solution(tickets):
    graph = defaultdict(list)
    
    # 그래프 구성
    for a, b in tickets:
        graph[a].append(b)
    
    # 사전순 보장을 위해 정렬
    for key in graph:
        graph[key].sort()
    
    route = ["ICN"]
    N = len(tickets)
    
    def dfs(cur):
        # 모든 항공권을 사용했으면 성공
        if len(route) == N + 1:
            return True
        
        for i, nxt in enumerate(graph[cur]):
            # 항공권 사용
            graph[cur].pop(i)
            route.append(nxt)
            
            if dfs(nxt):
                return True
            
            # 백트래킹 (상태 복구)
            route.pop()
            graph[cur].insert(i, nxt)
        
        return False
    
    dfs("ICN")
    return route

```
