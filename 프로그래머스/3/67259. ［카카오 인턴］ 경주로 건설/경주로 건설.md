## 풀이
* dp+다익스트라 방식으로 접근
* dp 좌표에 방향까지 추가한 3차원 배열을 만듬
* 처음 시작에서 오른쪽, 아래 방향을 heap에 넣음
* heap에서 최소 비용을 하나씩 꺼내서 그 방향에서 상하좌우 최소 비용을 또 heap 넣음
* 계속 진행해 최종 목적지에서 각 방향에서의 최소 비용을 출력
## 자료구조 및 알고리즘
* DP + 다익스트라
* Heap
## 문제 유형
* DP
## 시간 및 공간 복잡도
* 시간복잡도: $\mathcal{O}(n² log n)$
* 공간복잡도: $\mathcal{O}(n²)$
## 코드
```python
import heapq

def solution(board):
    n = len(board)
    INF = 10**9
    dp = [[[INF]*4 for _ in range(n)] for _ in range(n)]
    
    dirs = [(-1,0), (0,1), (1,0), (0,-1)]
    pq = []
    
    for dir, (nr, nc) in enumerate([(0,1), (1,0)]):
        if board[nr][nc] == 0:
            dp[nr][nc][dir+1] = 100
            heapq.heappush(pq, (100, nr, nc, dir+1))
    
    while pq:
        cost, r, c, dir = heapq.heappop(pq)
        if cost > dp[r][c][dir]:
            continue
        
        for ndir, (dr, dc) in enumerate(dirs):
            nr, nc = r + dr, c + dc
            if not (0 <= nr < n and 0 <= nc < n) or board[nr][nc]:
                continue
            
            ncost = cost + (100 if ndir == dir else 600)
            if ncost < dp[nr][nc][ndir]:
                dp[nr][nc][ndir] = ncost
                heapq.heappush(pq, (ncost, nr, nc, ndir))
    
    return min(dp[n-1][n-1])
```
